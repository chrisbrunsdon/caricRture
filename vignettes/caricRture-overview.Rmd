---
title: "Getting Started With CaricRture"
author: "Chris Brunsdon"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with CaracRture}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

The `caricRture` package is used to create maps (and possibly other graphics) that have the appearance of being hand drawn.  The algorithms used to acheive this are derived from [Wood *et. al.* (2012)](https://web.archive.org/web/20140913142528/http://openaccess.city.ac.uk/1274/). Hand drawn maps are useful to convey the impression that the geographical data being shown is in some way imprecise,  or vague.  The degree of 'roughness' of the hand drawing is controllable,  and it is possible to draw in a number of styles - for example to give the appearance of marker pens,  or pencil sketches.

## Setting up the package
At the moment,  the package exists only on `github`.  On an R session on a computer connected to the internet,  enter:
```{r, eval=FALSE}
install_github('chrisbrunsdon/caricRture')
```
to install the package.  To load the package,  just enter
```{r,message=FALSE}
library(caricRture)
```
The package is designed to work well with `dplyr`,  in particular tyhe *pipeline* approach,  and also to work with `SpatialPolygons`,`SpatialPolygonsDataFrame` classes of geographical objects as supplied by the `sp` package.  A practice `SpatialPolygonsDataFrame` based on Irish NUTS3 regions is provided in the data set `RA` - the actual object is called `RA.spdf`:
```{r,fig.width=5,fig.height=6,fig.align='center'}
data(RA)
RA.spdf %>% plot
```
Although the more conventional `plot(RA.spdf)` could have been used here,  the `%>%` form is useful,  as a general approach used by this package is to pipeline objects through various transformations,  quite often culminating in the `plot` command to produce a final map.   For example,  the `small_chop` function chops away smaller polygons that are part of multipolygons in spatial objects.  Typically these are small islands or enclaves.  Dropping these sometimes simplifies the shape of polygons,  which is useful for caricaturing and generalisation.
```{r,fig.width=5,fig.height=6,fig.align='center'}
RA.spdf %>% small_chop %>% plot
```
Notice that now the islands are no longer included in the map.  The form of the command illustrates the pipeline - the `SpatialPolygonsDataFrame` called `RA.spdf` is first fed into `small_chop`  and the output from this is fed into `plot`.  Again,  it is possible to use `plot(small_chop(RA.spdf))` here,  but this form is less legible.  This distinction would be even greater if there were several functions comprising the 'pipeline'.

## Some Basic Tools
The above example (`small_chop`) is a basic pipeline functuion to transform `SpatialPolygons` and `SpatialPolygonsDataFrames` - there are a number of these.  Another is the `generalise_it` function - the effectively reduces the number of points used to make up the polygons in an object - although it doesn't guarantee that the resultant polygons do not overlap. 
```{r,fig.width=5,fig.height=6,fig.align='center'}
RA.spdf %>% small_chop %>% generalise_it(10000) %>% plot
```
For those familiar,  this is actually the [Ramer-Douglas-Peuker Algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm) - although in this context the tolerance parameter is much higher than usually used - for example around 10km for mapsof Ireland.  Note also that it is most effective in this context if any small islands are removed before it is applied. At this stage a possible 'sketchy' map can be created.   To do this,  another function `sketch_it` is used.   However,  unlike `plot` it requires that a 'canvas' is specified - that is that the map extent is set up.  This can be done by passing a spatial object through the `make_canvas` function.  In pipeline terms,  this function returns its input unaltered,  but has the side effect of setting up a canvas. With this done, `sketch_it` may be used:

```{r,fig.width=5,fig.height=6,fig.align='center'}
RA.spdf %>% small_chop %>% generalise_it(10000) %>% make_canvas %>% sketch_it
```

The parameter `rough` allows the 'roughness' or sketchiness of the drawn lines to be controlled.  The default value is 0.05 - below a less rough sketch is created:
```{r,fig.width=5,fig.height=6,fig.align='center'}
RA.spdf %>% small_chop %>% generalise_it(10000) %>% make_canvas %>% sketch_it(rough=0.01)
```
It is also possible to 'tidy' the overlaps using the function `tidy_it` - when a pair of polygons overlap, this algorithm curts away the overlapping part of the larger polygon:
```{r,fig.width=5,fig.height=6,fig.align='center'}
RA.spdf %>% small_chop %>% generalise_it(10000) %>% tidy_it %>% plot
```
That was shown in non-sketchy form to make clear the geometrical process,  but is a useful tool for sketching as well:
```{r,fig.width=5,fig.height=6,fig.align='center'}
RA.spdf %>% small_chop %>% generalise_it(10000) %>% tidy_it %>% 
  make_canvas %>% sketch_it(rough=0.02,col='darkred')
```

## Hole Filling
The `tidy-it` function deals with overlaps bewtween component polygons,  but not gaps.  One way of dealing with gaps is to use the `dilate_it` function.  This essentially creates a buffer around each of the polygons.  The idea here is to expand them to fill out any holes.  It may be that in sketchy terms  the holes are not an issue and this is really a matter of style.  However since things are being represented in sketch form,  I see no problem with this.  Here,  the effect is shown:
```{r,fig.width=5,fig.height=6,fig.align='center'}
RA.spdf %>% small_chop %>% generalise_it(10000) %>% tidy_it %>% dilate_it(3500) %>% plot
```
In true Laurel and Hardy style,  of course this brings back lots of overlaps.  So,  tidy up again...
```{r,fig.width=5,fig.height=6,fig.align='center'}
RA.spdf %>% small_chop %>% generalise_it(10000) %>% tidy_it %>% 
  dilate_it(3500) %>% tidy_it %>% plot
```
This can be made sketchy without much difficulty:
```{r,fig.width=5,fig.height=6,fig.align='center'}
RA.spdf %>% small_chop %>% generalise_it(10000) %>% tidy_it %>% 
  dilate_it(3500) %>% tidy_it %>% make_canvas %>% sketch_it(col='maroon')
```

## Stylistic Modifications - Dealing With Outer Boundaries
Oddly,  although the holes are now filled in,   the overlapping lines on coterminous regions look overly complex,  compared to the border and coastal areas - the 'outer boundaries'.  There are a couple of work-arounds for this.  Firstly,  a function called `outline_it` finds the external outline of a set of polygons. By potting the external boundaries after the original map,  at least the external boundaries also get over-written,  so that the style is consistent.  Like `make_canvas`, `sketch_it` is another command that passes the input argument through,  drawing the sketchy map as a side effect.   This can be exploited here,  where the output (ie the object being sketched) is passed on to `outline_it` before being re-sketched.
```{r,fig.width=5,fig.height=6,fig.align='center'}
RA.spdf %>% small_chop %>% generalise_it(10000) %>% tidy_it %>% 
  dilate_it(3500) %>% tidy_it %>% make_canvas %>% sketch_it(col='darkorange') %>%
  outline_it %>% sketch_it(col=NA)
```
The alternative is to use `contract_it` - this effectively buffers all of the polygons inwardly by a fixed amount.  This then leaves a clear gap between each polygon.  Sometimes this is useful - unlike the holes earlier these are evenly distributed,  and really just constitute an alternative sketch style.   Here is the result of using this approach:
```{r,fig.width=5,fig.height=6,fig.align='center'}
RA.spdf %>% small_chop %>% generalise_it(10000) %>% tidy_it %>% 
  dilate_it(3500) %>% tidy_it %>% contract_it(3000) %>% 
  make_canvas %>% sketch_it(col='turquoise') 
```

## Curvy Representations
As well as 'hand-drawn' effects, `caricRture` also offers curvy representations of boundaries.   These are achieved using the `curve_it` function.  This takes a 'shape' parameter.   If this is zero,  the transformed shapes are identical to those input,  and if equal to one a much smoother curve results - the function makes use of the `xspline` function - the help page for this explains in greater detail.   Values between zero and one result in intermediate degrees of smoothness. Here,  it is used to provide a 'curvy' version of the Irish regions:
```{r,fig.width=5,fig.height=6,fig.align='center',fig.keep='last'}
plot.new()
RA.spdf %>% small_chop %>% generalise_it(10000) %>% tidy_it %>% 
  dilate_it(3500) %>% tidy_it %>% curve_it(0.8) %>% plot
```




